<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - birds</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>

		</style>
	</head>
	<body>

		<div id="container"></div>
		<!-- <div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - birds demo</div> -->

		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
		<script type="text/javascript" src="js/OrbitControls.js"></script>
		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>
		<script src="js/boydAlgo.js"></script>
		<script src="obj/Bird.js"></script>
		



		<script>
			var clock = new THREE.Clock();
			let up = false;
			let down = false;
			let right = false;
			let left = false;

			var SCREEN_WIDTH = window.innerWidth,
			SCREEN_HEIGHT = window.innerHeight,
			SCREEN_WIDTH_HALF = SCREEN_WIDTH  / 2,
			SCREEN_HEIGHT_HALF = SCREEN_HEIGHT / 2;

			var camera, scene, renderer, birds, bird;

			var boid, boids;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000 );
				camera.position.z = 0;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );

				birds = [];
				boids = [];

				for ( var i = 0; i < 200; i ++ ) {

					boid = boids[ i ] = new Boid();
					boid.position.x = Math.random() * 400 - 200;
					boid.position.y = Math.random() * 400 - 200;
					boid.position.z = Math.random() * 400 - 200;
					boid.velocity.x = Math.random() * 2 - 1;
					boid.velocity.y = Math.random() * 2 - 1;
					boid.velocity.z = Math.random() * 2 - 1;
					boid.setAvoidWalls( true );
					boid.setWorldSize( 200, 200, 1000 );

					bird = birds[ i ] = new THREE.Mesh( new Bird(), new THREE.MeshBasicMaterial( { color:Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
					bird.phase = Math.floor( Math.random() * 62.83 );
					scene.add( bird );


				}

				renderer = new THREE.CanvasRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				var vector = new THREE.Vector3( event.clientX - SCREEN_WIDTH_HALF, - event.clientY + SCREEN_HEIGHT_HALF, 0 );
				for ( var i = 0, il = boids.length; i < il; i++ ) {
					boid = boids[ i ];
					vector.z = boid.position.z;
					boid.repulse( vector );
				}

			}
			function animate() {
				requestAnimationFrame( animate );
				//steering 
				camSteer();
				render();
			}

			function render() {

				for ( var i = 0, il = birds.length; i < il; i++ ) {

					boid = boids[ i ];
					boid.run( boids );

					bird = birds[ i ];
					bird.position.copy( boids[ i ].position );

					var color = bird.material.color;
					color.r = color.g = color.b = ( 500 - bird.position.z ) / 1000;

					bird.rotation.y = Math.atan2( - boid.velocity.z, boid.velocity.x );
					bird.rotation.z = Math.asin( boid.velocity.y / boid.velocity.length() );

					bird.phase = ( bird.phase + ( Math.max( 0, bird.rotation.z ) + 0.1 )  ) % 62.83;
					bird.geometry.vertices[ 5 ].y = bird.geometry.vertices[ 4 ].y = Math.sin( bird.phase ) * 5;

				}

				renderer.render( scene, camera );

			}

/////////////////////Add Steering cube/////////////////////////


function addCube(){
	var MovingCubeMat = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
	var MovingCubeGeom = new THREE.BoxGeometry( 1, 1, 1, 1, 1, 1 );
	MovingCube = new THREE.Mesh( MovingCubeGeom, MovingCubeMat );
	MovingCube.position.set(0, 5, 0);
	scene.add( MovingCube );  
	console.log('cube')
}
addCube();

/////////////////////Steer the camera and birds/////////////////////////



function camSteer(){
//   var delta = clock.getDelta(); // seconds.
//   var moveDistance = 100 * delta; // 200 pixels per second
//   var rotateAngle = Math.PI / 5 * delta;   // pi/2 radians (90 degrees) per second
  
//   // local transformations
//   //MovingCube.translateZ( -moveDistance );
//   controler()
//   // move forwards/backwards/left/right
//   if (up==true){
//     // MovingCube.rotateOnAxis( new THREE.Vector4(1,0,0), rotateAngle);
//     //MovingCube.translateY(  moveDistance );
//     //console.log('up')
//   }
//     if (down==true){
//     // MovingCube.rotateOnAxis( new THREE.Vector4(1,0,0), -rotateAngle);
//     //MovingCube.translateY(  -moveDistance );
//     console.log('down')
//   }
//     if (right==true){
//     // MovingCube.rotateOnAxis( new THREE.Vector4(0,1,0), -rotateAngle);
//     console.log('right')
//   }
//     if (left==true){
//     // MovingCube.rotateOnAxis( new THREE.Vector4(0,1,0), rotateAngle);
//     console.log('left')
//   }
    
//   // POTENTALLY CAN  MAKE THIS RESET THE POSITION 
//   //   MovingCube.position.set(0,25.1,0);
//   //   MovingCube.rotation.set(0,0,0);
  
//   var relativeCameraOffset = new THREE.Vector3(0,5,20);

//   var cameraOffset = relativeCameraOffset.applyMatrix4( MovingCube.matrixWorld );
//   camera.position.x = cameraOffset.x;
//   camera.position.y = cameraOffset.y;
//   camera.position.z = cameraOffset.z;
//   camera.lookAt( MovingCube.position );
//   camera.updateMatrix();
//   camera.updateProjectionMatrix();
}


/////////////////////handle keypress/////////////////////////

var Key = {
  // translates the keys into english
  _pressed: {},LEFT: 37,UP: 38,RIGHT: 39,DOWN: 40,
  //return if pressed, on or off
  isDown: function(keyCode) { return this._pressed[keyCode];},
  onKeydown: function(event) {this._pressed[event.keyCode] = true;},
  onKeyup: function(event) {delete this._pressed[event.keyCode];}
};

// what to do if arrow key pressed
let controler = function() {
  if (Key.isDown(Key.UP)) up=true;
  else up=false 
  if (Key.isDown(Key.LEFT)) left=true;
  else left=false 
  if (Key.isDown(Key.DOWN)) down=true;
  else down=false 
  if (Key.isDown(Key.RIGHT))  right=true;
  else right=false 
};

// Key listener
window.addEventListener('keyup', function(event) { Key.onKeyup(event); }, false);
window.addEventListener('keydown', function(event) { Key.onKeydown(event); }, false);




		</script>

	</body>
</html>

